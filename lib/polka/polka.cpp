// This file is generated by kxml_compiler from polka.xml.
// All changes you do to this file will be lost.
/*
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
    USA.
*/

#include "polka.h"

#include <QtDebug>
#include <QFile>
#include <QDomDocument>
#include <QtCore/QtDebug>
#include <QtCore/QFile>

namespace Polka {

bool ViewLabel::isValid() const
{
  return !mId.isEmpty();
}

void ViewLabel::setId( const QString &v )
{
  mId = v;
}

QString ViewLabel::id() const
{
  return mId;
}

void ViewLabel::setText( const QString &v )
{
  mText = v;
}

QString ViewLabel::text() const
{
  return mText;
}

void ViewLabel::setX( int v )
{
  mX = v;
}

int ViewLabel::x() const
{
  return mX;
}

void ViewLabel::setY( int v )
{
  mY = v;
}

int ViewLabel::y() const
{
  return mY;
}

ViewLabel ViewLabel::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "view_label" ) {
    qCritical() << "Expected 'view_label', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return ViewLabel();
  }

  ViewLabel result = ViewLabel();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "text" ) {
      result.setText( e.text() );
    }
    else if ( e.tagName() == "x" ) {
      result.setX( e.text().toInt() );
    }
    else if ( e.tagName() == "y" ) {
      result.setY( e.text().toInt() );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void ViewLabel::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "view_label" );
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  if ( !text().isEmpty() ) {
    xml.writeTextElement(  "text", text() );
  }
  xml.writeTextElement(  "x", QString::number( x() ) );
  xml.writeTextElement(  "y", QString::number( y() ) );
  xml.writeEndElement();
}


bool IdentityCheck::isValid() const
{
  return !mId.isEmpty();
}

void IdentityCheck::setId( const QString &v )
{
  mId = v;
}

QString IdentityCheck::id() const
{
  return mId;
}

void IdentityCheck::setChecked( const QString &v )
{
  mChecked = v;
}

QString IdentityCheck::checked() const
{
  return mChecked;
}

IdentityCheck IdentityCheck::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "identity_check" ) {
    qCritical() << "Expected 'identity_check', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return IdentityCheck();
  }

  IdentityCheck result = IdentityCheck();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "checked" ) {
      result.setChecked( e.text() );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void IdentityCheck::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "identity_check" );
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  if ( !checked().isEmpty() ) {
    xml.writeTextElement(  "checked", checked() );
  }
  xml.writeEndElement();
}


bool IdentityPosition::isValid() const
{
  return !mId.isEmpty();
}

void IdentityPosition::setId( const QString &v )
{
  mId = v;
}

QString IdentityPosition::id() const
{
  return mId;
}

void IdentityPosition::setX( int v )
{
  mX = v;
}

int IdentityPosition::x() const
{
  return mX;
}

void IdentityPosition::setY( int v )
{
  mY = v;
}

int IdentityPosition::y() const
{
  return mY;
}

IdentityPosition IdentityPosition::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "identity_position" ) {
    qCritical() << "Expected 'identity_position', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return IdentityPosition();
  }

  IdentityPosition result = IdentityPosition();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "x" ) {
      result.setX( e.text().toInt() );
    }
    else if ( e.tagName() == "y" ) {
      result.setY( e.text().toInt() );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void IdentityPosition::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "identity_position" );
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  xml.writeTextElement(  "x", QString::number( x() ) );
  xml.writeTextElement(  "y", QString::number( y() ) );
  xml.writeEndElement();
}


bool GroupView::isValid() const
{
  return !mId.isEmpty();
}

void GroupView::setId( const QString &v )
{
  mId = v;
}

QString GroupView::id() const
{
  return mId;
}

void GroupView::addIdentityPosition( const IdentityPosition &v )
{
  mIdentityPositionList.append( v );
}

void GroupView::setIdentityPositionList( const IdentityPosition::List &v )
{
  mIdentityPositionList = v;
}

IdentityPosition::List GroupView::identityPositionList() const
{
  return mIdentityPositionList;
}

IdentityPosition GroupView::findIdentityPosition( const QString &id, Flags flags )
{
  foreach( IdentityPosition v, mIdentityPositionList ) {
    if ( v.id() == id ) return v;
  }
  IdentityPosition v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool GroupView::insert( const IdentityPosition &v )
{
  int i = 0;
  for( ; i < mIdentityPositionList.size(); ++i ) {
    if ( mIdentityPositionList[i].id() == v.id() ) {
      mIdentityPositionList[i] = v;
      return true;
    }
  }
  if ( i == mIdentityPositionList.size() ) {
    addIdentityPosition( v );
  }
  return true;
}

bool GroupView::remove( const IdentityPosition &v )
{
  IdentityPosition::List::Iterator it;
  for( it = mIdentityPositionList.begin(); it != mIdentityPositionList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mIdentityPositionList.end() ) {
    mIdentityPositionList.erase( it );
  }
  return true;
}

void GroupView::addIdentityCheck( const IdentityCheck &v )
{
  mIdentityCheckList.append( v );
}

void GroupView::setIdentityCheckList( const IdentityCheck::List &v )
{
  mIdentityCheckList = v;
}

IdentityCheck::List GroupView::identityCheckList() const
{
  return mIdentityCheckList;
}

IdentityCheck GroupView::findIdentityCheck( const QString &id, Flags flags )
{
  foreach( IdentityCheck v, mIdentityCheckList ) {
    if ( v.id() == id ) return v;
  }
  IdentityCheck v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool GroupView::insert( const IdentityCheck &v )
{
  int i = 0;
  for( ; i < mIdentityCheckList.size(); ++i ) {
    if ( mIdentityCheckList[i].id() == v.id() ) {
      mIdentityCheckList[i] = v;
      return true;
    }
  }
  if ( i == mIdentityCheckList.size() ) {
    addIdentityCheck( v );
  }
  return true;
}

bool GroupView::remove( const IdentityCheck &v )
{
  IdentityCheck::List::Iterator it;
  for( it = mIdentityCheckList.begin(); it != mIdentityCheckList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mIdentityCheckList.end() ) {
    mIdentityCheckList.erase( it );
  }
  return true;
}

void GroupView::addViewLabel( const ViewLabel &v )
{
  mViewLabelList.append( v );
}

void GroupView::setViewLabelList( const ViewLabel::List &v )
{
  mViewLabelList = v;
}

ViewLabel::List GroupView::viewLabelList() const
{
  return mViewLabelList;
}

ViewLabel GroupView::findViewLabel( const QString &id, Flags flags )
{
  foreach( ViewLabel v, mViewLabelList ) {
    if ( v.id() == id ) return v;
  }
  ViewLabel v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool GroupView::insert( const ViewLabel &v )
{
  int i = 0;
  for( ; i < mViewLabelList.size(); ++i ) {
    if ( mViewLabelList[i].id() == v.id() ) {
      mViewLabelList[i] = v;
      return true;
    }
  }
  if ( i == mViewLabelList.size() ) {
    addViewLabel( v );
  }
  return true;
}

bool GroupView::remove( const ViewLabel &v )
{
  ViewLabel::List::Iterator it;
  for( it = mViewLabelList.begin(); it != mViewLabelList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mViewLabelList.end() ) {
    mViewLabelList.erase( it );
  }
  return true;
}

GroupView GroupView::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "group_view" ) {
    qCritical() << "Expected 'group_view', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return GroupView();
  }

  GroupView result = GroupView();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "identity_position" ) {
      bool ok;
      IdentityPosition o = IdentityPosition::parseElement( e, &ok );
      if ( ok ) result.addIdentityPosition( o );
    }
    else if ( e.tagName() == "identity_check" ) {
      bool ok;
      IdentityCheck o = IdentityCheck::parseElement( e, &ok );
      if ( ok ) result.addIdentityCheck( o );
    }
    else if ( e.tagName() == "view_label" ) {
      bool ok;
      ViewLabel o = ViewLabel::parseElement( e, &ok );
      if ( ok ) result.addViewLabel( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void GroupView::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "group_view" );
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  foreach( IdentityPosition e, identityPositionList() ) {
    e.writeElement( xml );
  }
  foreach( IdentityCheck e, identityCheckList() ) {
    e.writeElement( xml );
  }
  foreach( ViewLabel e, viewLabelList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


Comment::Comment()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

bool Comment::isValid() const
{
  return !mId.isEmpty();
}

void Comment::setId( const QString &v )
{
  mId = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Comment::id() const
{
  return mId;
}

void Comment::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Comment::createdAt() const
{
  return mCreatedAt;
}

void Comment::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Comment::updatedAt() const
{
  return mUpdatedAt;
}

void Comment::setValue( const QString &v )
{
  mValue = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Comment::value() const
{
  return mValue;
}

Comment Comment::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "comment" ) {
    qCritical() << "Expected 'comment', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Comment();
  }

  Comment result = Comment();

  result.setValue( element.text() );
  result.setId( element.attribute( "id" ) );
  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Comment::writeElement( QXmlStreamWriter &xml )
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "comment" );
    if ( !id().isEmpty() ) {
      xml.writeAttribute( "id", id() );
    }
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


void Comments::addComment( const Comment &v )
{
  mCommentList.append( v );
}

void Comments::setCommentList( const Comment::List &v )
{
  mCommentList = v;
}

Comment::List Comments::commentList() const
{
  return mCommentList;
}

Comment Comments::findComment( const QString &id, Flags flags )
{
  foreach( Comment v, mCommentList ) {
    if ( v.id() == id ) return v;
  }
  Comment v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Comments::insert( const Comment &v )
{
  int i = 0;
  for( ; i < mCommentList.size(); ++i ) {
    if ( mCommentList[i].id() == v.id() ) {
      mCommentList[i] = v;
      return true;
    }
  }
  if ( i == mCommentList.size() ) {
    addComment( v );
  }
  return true;
}

bool Comments::remove( const Comment &v )
{
  Comment::List::Iterator it;
  for( it = mCommentList.begin(); it != mCommentList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mCommentList.end() ) {
    mCommentList.erase( it );
  }
  return true;
}

Comments Comments::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "comments" ) {
    qCritical() << "Expected 'comments', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Comments();
  }

  Comments result = Comments();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.addComment( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Comments::writeElement( QXmlStreamWriter &xml )
{
  if ( !commentList().isEmpty() ) {
    xml.writeStartElement( "comments" );
    foreach( Comment e, commentList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Attribute::Attribute()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

void Attribute::setType( const QString &v )
{
  mType = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Attribute::type() const
{
  return mType;
}

void Attribute::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Attribute::createdAt() const
{
  return mCreatedAt;
}

void Attribute::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Attribute::updatedAt() const
{
  return mUpdatedAt;
}

void Attribute::setKey( const QString &v )
{
  mKey = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Attribute::key() const
{
  return mKey;
}

void Attribute::setValue( const QString &v )
{
  mValue = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Attribute::value() const
{
  return mValue;
}

void Attribute::setComment( const Comment &v )
{
  mComment = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

Comment Attribute::comment() const
{
  return mComment;
}

Attribute Attribute::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "attribute" ) {
    qCritical() << "Expected 'attribute', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Attribute();
  }

  Attribute result = Attribute();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "key" ) {
      result.setKey( e.text() );
    }
    else if ( e.tagName() == "value" ) {
      result.setValue( e.text() );
    }
    else if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.setComment( o );
    }
  }

  result.setType( element.attribute( "type" ) );
  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Attribute::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "attribute" );
    if ( !type().isEmpty() ) {
      xml.writeAttribute( "type", type() );
    }
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
  if ( !key().isEmpty() ) {
    xml.writeTextElement(  "key", key() );
  }
  if ( !value().isEmpty() ) {
    xml.writeTextElement(  "value", value() );
  }
  comment().writeElement( xml );
  xml.writeEndElement();
}


void ExtendedAttributes::addAttribute( const Attribute &v )
{
  mAttributeList.append( v );
}

void ExtendedAttributes::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List ExtendedAttributes::attributeList() const
{
  return mAttributeList;
}

ExtendedAttributes ExtendedAttributes::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "extended_attributes" ) {
    qCritical() << "Expected 'extended_attributes', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return ExtendedAttributes();
  }

  ExtendedAttributes result = ExtendedAttributes();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute o = Attribute::parseElement( e, &ok );
      if ( ok ) result.addAttribute( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void ExtendedAttributes::writeElement( QXmlStreamWriter &xml )
{
  if ( !attributeList().isEmpty() ) {
    xml.writeStartElement( "extended_attributes" );
    foreach( Attribute e, attributeList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Link::Link()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

bool Link::isValid() const
{
  return !mId.isEmpty();
}

void Link::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Link::createdAt() const
{
  return mCreatedAt;
}

void Link::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Link::updatedAt() const
{
  return mUpdatedAt;
}

void Link::setId( const QString &v )
{
  mId = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Link::id() const
{
  return mId;
}

void Link::setLinkType( const QString &v )
{
  mLinkType = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Link::linkType() const
{
  return mLinkType;
}

void Link::setUrl( const QString &v )
{
  mUrl = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Link::url() const
{
  return mUrl;
}

void Link::setComment( const Comment &v )
{
  mComment = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

Comment Link::comment() const
{
  return mComment;
}

Link Link::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "link" ) {
    qCritical() << "Expected 'link', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Link();
  }

  Link result = Link();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "link_type" ) {
      result.setLinkType( e.text() );
    }
    else if ( e.tagName() == "url" ) {
      result.setUrl( e.text() );
    }
    else if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.setComment( o );
    }
  }

  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Link::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "link" );
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  if ( !linkType().isEmpty() ) {
    xml.writeTextElement(  "link_type", linkType() );
  }
  if ( !url().isEmpty() ) {
    xml.writeTextElement(  "url", url() );
  }
  comment().writeElement( xml );
  xml.writeEndElement();
}


void Links::addLink( const Link &v )
{
  mLinkList.append( v );
}

void Links::setLinkList( const Link::List &v )
{
  mLinkList = v;
}

Link::List Links::linkList() const
{
  return mLinkList;
}

Link Links::findLink( const QString &id, Flags flags )
{
  foreach( Link v, mLinkList ) {
    if ( v.id() == id ) return v;
  }
  Link v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Links::insert( const Link &v )
{
  int i = 0;
  for( ; i < mLinkList.size(); ++i ) {
    if ( mLinkList[i].id() == v.id() ) {
      mLinkList[i] = v;
      return true;
    }
  }
  if ( i == mLinkList.size() ) {
    addLink( v );
  }
  return true;
}

bool Links::remove( const Link &v )
{
  Link::List::Iterator it;
  for( it = mLinkList.begin(); it != mLinkList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mLinkList.end() ) {
    mLinkList.erase( it );
  }
  return true;
}

Links Links::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "links" ) {
    qCritical() << "Expected 'links', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Links();
  }

  Links result = Links();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "link" ) {
      bool ok;
      Link o = Link::parseElement( e, &ok );
      if ( ok ) result.addLink( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Links::writeElement( QXmlStreamWriter &xml )
{
  if ( !linkList().isEmpty() ) {
    xml.writeStartElement( "links" );
    foreach( Link e, linkList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


void Relation::setRelationType( const QString &v )
{
  mRelationType = v;
}

QString Relation::relationType() const
{
  return mRelationType;
}

void Relation::setTarget( const QString &v )
{
  mTarget = v;
}

QString Relation::target() const
{
  return mTarget;
}

Relation Relation::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "relation" ) {
    qCritical() << "Expected 'relation', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Relation();
  }

  Relation result = Relation();

  result.setRelationType( element.attribute( "relation_type" ) );
  result.setTarget( element.attribute( "target" ) );

  if ( ok ) *ok = true;
  return result;
}

void Relation::writeElement( QXmlStreamWriter &xml )
{
  xml.writeEmptyElement( "relation" );
}


void Relations::addRelation( const Relation &v )
{
  mRelationList.append( v );
}

void Relations::setRelationList( const Relation::List &v )
{
  mRelationList = v;
}

Relation::List Relations::relationList() const
{
  return mRelationList;
}

Relations Relations::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "relations" ) {
    qCritical() << "Expected 'relations', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Relations();
  }

  Relations result = Relations();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "relation" ) {
      bool ok;
      Relation o = Relation::parseElement( e, &ok );
      if ( ok ) result.addRelation( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Relations::writeElement( QXmlStreamWriter &xml )
{
  if ( !relationList().isEmpty() ) {
    xml.writeStartElement( "relations" );
    foreach( Relation e, relationList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Address::Address()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

bool Address::isValid() const
{
  return !mId.isEmpty();
}

void Address::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Address::createdAt() const
{
  return mCreatedAt;
}

void Address::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Address::updatedAt() const
{
  return mUpdatedAt;
}

void Address::setId( const QString &v )
{
  mId = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Address::id() const
{
  return mId;
}

void Address::setLabel( const QString &v )
{
  mLabel = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Address::label() const
{
  return mLabel;
}

void Address::setComment( const Comment &v )
{
  mComment = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

Comment Address::comment() const
{
  return mComment;
}

Address Address::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "address" ) {
    qCritical() << "Expected 'address', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Address();
  }

  Address result = Address();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "label" ) {
      result.setLabel( e.text() );
    }
    else if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.setComment( o );
    }
  }

  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Address::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "address" );
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  if ( !label().isEmpty() ) {
    xml.writeTextElement(  "label", label() );
  }
  comment().writeElement( xml );
  xml.writeEndElement();
}


void Addresses::addAddress( const Address &v )
{
  mAddressList.append( v );
}

void Addresses::setAddressList( const Address::List &v )
{
  mAddressList = v;
}

Address::List Addresses::addressList() const
{
  return mAddressList;
}

Address Addresses::findAddress( const QString &id, Flags flags )
{
  foreach( Address v, mAddressList ) {
    if ( v.id() == id ) return v;
  }
  Address v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Addresses::insert( const Address &v )
{
  int i = 0;
  for( ; i < mAddressList.size(); ++i ) {
    if ( mAddressList[i].id() == v.id() ) {
      mAddressList[i] = v;
      return true;
    }
  }
  if ( i == mAddressList.size() ) {
    addAddress( v );
  }
  return true;
}

bool Addresses::remove( const Address &v )
{
  Address::List::Iterator it;
  for( it = mAddressList.begin(); it != mAddressList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mAddressList.end() ) {
    mAddressList.erase( it );
  }
  return true;
}

Addresses Addresses::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "addresses" ) {
    qCritical() << "Expected 'addresses', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Addresses();
  }

  Addresses result = Addresses();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "address" ) {
      bool ok;
      Address o = Address::parseElement( e, &ok );
      if ( ok ) result.addAddress( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Addresses::writeElement( QXmlStreamWriter &xml )
{
  if ( !addressList().isEmpty() ) {
    xml.writeStartElement( "addresses" );
    foreach( Address e, addressList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Phone::Phone()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

bool Phone::isValid() const
{
  return !mId.isEmpty();
}

void Phone::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Phone::createdAt() const
{
  return mCreatedAt;
}

void Phone::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Phone::updatedAt() const
{
  return mUpdatedAt;
}

void Phone::setId( const QString &v )
{
  mId = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Phone::id() const
{
  return mId;
}

void Phone::setPhoneType( const QString &v )
{
  mPhoneType = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Phone::phoneType() const
{
  return mPhoneType;
}

void Phone::setPhoneNumber( const QString &v )
{
  mPhoneNumber = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Phone::phoneNumber() const
{
  return mPhoneNumber;
}

void Phone::setComment( const Comment &v )
{
  mComment = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

Comment Phone::comment() const
{
  return mComment;
}

Phone Phone::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "phone" ) {
    qCritical() << "Expected 'phone', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Phone();
  }

  Phone result = Phone();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "phone_type" ) {
      result.setPhoneType( e.text() );
    }
    else if ( e.tagName() == "phone_number" ) {
      result.setPhoneNumber( e.text() );
    }
    else if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.setComment( o );
    }
  }

  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Phone::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "phone" );
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  if ( !phoneType().isEmpty() ) {
    xml.writeTextElement(  "phone_type", phoneType() );
  }
  if ( !phoneNumber().isEmpty() ) {
    xml.writeTextElement(  "phone_number", phoneNumber() );
  }
  comment().writeElement( xml );
  xml.writeEndElement();
}


void Phones::addPhone( const Phone &v )
{
  mPhoneList.append( v );
}

void Phones::setPhoneList( const Phone::List &v )
{
  mPhoneList = v;
}

Phone::List Phones::phoneList() const
{
  return mPhoneList;
}

Phone Phones::findPhone( const QString &id, Flags flags )
{
  foreach( Phone v, mPhoneList ) {
    if ( v.id() == id ) return v;
  }
  Phone v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Phones::insert( const Phone &v )
{
  int i = 0;
  for( ; i < mPhoneList.size(); ++i ) {
    if ( mPhoneList[i].id() == v.id() ) {
      mPhoneList[i] = v;
      return true;
    }
  }
  if ( i == mPhoneList.size() ) {
    addPhone( v );
  }
  return true;
}

bool Phones::remove( const Phone &v )
{
  Phone::List::Iterator it;
  for( it = mPhoneList.begin(); it != mPhoneList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mPhoneList.end() ) {
    mPhoneList.erase( it );
  }
  return true;
}

Phones Phones::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "phones" ) {
    qCritical() << "Expected 'phones', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Phones();
  }

  Phones result = Phones();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "phone" ) {
      bool ok;
      Phone o = Phone::parseElement( e, &ok );
      if ( ok ) result.addPhone( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Phones::writeElement( QXmlStreamWriter &xml )
{
  if ( !phoneList().isEmpty() ) {
    xml.writeStartElement( "phones" );
    foreach( Phone e, phoneList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Picture::Picture()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

bool Picture::isValid() const
{
  return !mId.isEmpty();
}

void Picture::setPictureType( const QString &v )
{
  mPictureType = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Picture::pictureType() const
{
  return mPictureType;
}

void Picture::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Picture::createdAt() const
{
  return mCreatedAt;
}

void Picture::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Picture::updatedAt() const
{
  return mUpdatedAt;
}

void Picture::setId( const QString &v )
{
  mId = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Picture::id() const
{
  return mId;
}

void Picture::setUrl( const QString &v )
{
  mUrl = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Picture::url() const
{
  return mUrl;
}

void Picture::setComment( const Comment &v )
{
  mComment = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

Comment Picture::comment() const
{
  return mComment;
}

Picture Picture::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "picture" ) {
    qCritical() << "Expected 'picture', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Picture();
  }

  Picture result = Picture();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "url" ) {
      result.setUrl( e.text() );
    }
    else if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.setComment( o );
    }
  }

  result.setPictureType( element.attribute( "picture_type" ) );
  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Picture::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "picture" );
    if ( !pictureType().isEmpty() ) {
      xml.writeAttribute( "picture_type", pictureType() );
    }
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  if ( !url().isEmpty() ) {
    xml.writeTextElement(  "url", url() );
  }
  comment().writeElement( xml );
  xml.writeEndElement();
}


void Pictures::setSelected( const QString &v )
{
  mSelected = v;
}

QString Pictures::selected() const
{
  return mSelected;
}

void Pictures::addPicture( const Picture &v )
{
  mPictureList.append( v );
}

void Pictures::setPictureList( const Picture::List &v )
{
  mPictureList = v;
}

Picture::List Pictures::pictureList() const
{
  return mPictureList;
}

Picture Pictures::findPicture( const QString &id, Flags flags )
{
  foreach( Picture v, mPictureList ) {
    if ( v.id() == id ) return v;
  }
  Picture v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Pictures::insert( const Picture &v )
{
  int i = 0;
  for( ; i < mPictureList.size(); ++i ) {
    if ( mPictureList[i].id() == v.id() ) {
      mPictureList[i] = v;
      return true;
    }
  }
  if ( i == mPictureList.size() ) {
    addPicture( v );
  }
  return true;
}

bool Pictures::remove( const Picture &v )
{
  Picture::List::Iterator it;
  for( it = mPictureList.begin(); it != mPictureList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mPictureList.end() ) {
    mPictureList.erase( it );
  }
  return true;
}

Pictures Pictures::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pictures" ) {
    qCritical() << "Expected 'pictures', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Pictures();
  }

  Pictures result = Pictures();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "selected" ) {
      result.setSelected( e.text() );
    }
    else if ( e.tagName() == "picture" ) {
      bool ok;
      Picture o = Picture::parseElement( e, &ok );
      if ( ok ) result.addPicture( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Pictures::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "pictures" );
  if ( !selected().isEmpty() ) {
    xml.writeTextElement(  "selected", selected() );
  }
  foreach( Picture e, pictureList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}


Detail::Detail()
{
    QDateTime now = QDateTime::currentDateTime();
    setCreatedAt( now );
    setUpdatedAt( now );
}

bool Detail::isValid() const
{
    return !mId.isEmpty();
}

void Detail::setId(const QString& v)
{
    mId = v;
    setUpdatedAt( QDateTime::currentDateTime() );
}

QString Detail::id() const
{
    return mId;
}

void Detail::setCreatedAt(const QDateTime& v)
{
    mCreatedAt = v;
}

QDateTime Detail::createdAt() const
{
    return mCreatedAt;
}

void Detail::setUpdatedAt(const QDateTime& v)
{
    mUpdatedAt = v;
}

QDateTime Detail::updatedAt() const
{
    return mUpdatedAt;
}

void Detail::setDetailName(const QString& v)
{
    mDetailName = v;
    setUpdatedAt( QDateTime::currentDateTime() );
}

QString Detail::detailName() const
{
    return mDetailName;
}

void Detail::setDetailValue(const QString& v)
{
    mDetailValue = v;
    setUpdatedAt( QDateTime::currentDateTime() );
}

QString Detail::detailValue() const
{
    return mDetailValue;
}

void Detail::setComment(const Comment& v)
{
    mComment = v;
    setUpdatedAt( QDateTime::currentDateTime() );
}

Comment Detail::comment() const
{
    return mComment;
}

Detail Detail::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "detail" ) {
    qCritical() << "Expected 'detail', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Detail();
  }

  Detail result = Detail();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "detail_name" ) {
      result.setDetailName( e.text() );
    }
    else if ( e.tagName() == "detail_value" ) {
        result.setDetailValue( e.text() );
    }
    else if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.setComment( o );
    }
  }

  result.setId( element.attribute( "id" ) );
  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Detail::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "detail" );
    if ( !id().isEmpty() ) {
      xml.writeAttribute( "id", id() );
    }
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
  if ( !detailName().isEmpty() ) {
    xml.writeTextElement(  "detail_name", detailName() );
  }
  if ( !detailValue().isEmpty() ) {
    xml.writeTextElement(  "detail_value", detailValue() );
  }
  comment().writeElement( xml );
  xml.writeEndElement();
}


void Details::addDetail( const Detail &v )
{
  mDetailList.append( v );
}

void Details::setDetailList( const Detail::List &v )
{
  mDetailList = v;
}

Detail::List Details::detailList() const
{
  return mDetailList;
}

Detail Details::findDetail( const QString &id, Flags flags )
{
  foreach( Detail v, mDetailList ) {
    if ( v.id() == id ) return v;
  }
  Detail v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Details::insert( const Detail &v )
{
  int i = 0;
  for( ; i < mDetailList.size(); ++i ) {
    if ( mDetailList[i].id() == v.id() ) {
      mDetailList[i] = v;
      return true;
    }
  }
  if ( i == mDetailList.size() ) {
    addDetail( v );
  }
  return true;
}

bool Details::remove( const Detail &v )
{
  Detail::List::Iterator it;
  for( it = mDetailList.begin(); it != mDetailList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mDetailList.end() ) {
    mDetailList.erase( it );
  }
  return true;
}

Details Details::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "details" ) {
    qCritical() << "Expected 'details', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Details();
  }

  Details result = Details();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "detail" ) {
      bool ok;
      Detail o = Detail::parseElement( e, &ok );
      if ( ok ) result.addDetail( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Details::writeElement( QXmlStreamWriter &xml )
{
  if ( !detailList().isEmpty() ) {
    xml.writeStartElement( "details" );
    foreach( Detail e, detailList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Email::Email()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

bool Email::isValid() const
{
  return !mId.isEmpty();
}

void Email::setId( const QString &v )
{
  mId = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Email::id() const
{
  return mId;
}

void Email::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Email::createdAt() const
{
  return mCreatedAt;
}

void Email::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Email::updatedAt() const
{
  return mUpdatedAt;
}

void Email::setEmailAddress( const QString &v )
{
  mEmailAddress = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Email::emailAddress() const
{
  return mEmailAddress;
}

void Email::setComment( const Comment &v )
{
  mComment = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

Comment Email::comment() const
{
  return mComment;
}

Email Email::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "email" ) {
    qCritical() << "Expected 'email', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Email();
  }

  Email result = Email();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "email_address" ) {
      result.setEmailAddress( e.text() );
    }
    else if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.setComment( o );
    }
  }

  result.setId( element.attribute( "id" ) );
  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Email::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "email" );
    if ( !id().isEmpty() ) {
      xml.writeAttribute( "id", id() );
    }
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
  if ( !emailAddress().isEmpty() ) {
    xml.writeTextElement(  "email_address", emailAddress() );
  }
  comment().writeElement( xml );
  xml.writeEndElement();
}


void Emails::addEmail( const Email &v )
{
  mEmailList.append( v );
}

void Emails::setEmailList( const Email::List &v )
{
  mEmailList = v;
}

Email::List Emails::emailList() const
{
  return mEmailList;
}

Email Emails::findEmail( const QString &id, Flags flags )
{
  foreach( Email v, mEmailList ) {
    if ( v.id() == id ) return v;
  }
  Email v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Emails::insert( const Email &v )
{
  int i = 0;
  for( ; i < mEmailList.size(); ++i ) {
    if ( mEmailList[i].id() == v.id() ) {
      mEmailList[i] = v;
      return true;
    }
  }
  if ( i == mEmailList.size() ) {
    addEmail( v );
  }
  return true;
}

bool Emails::remove( const Email &v )
{
  Email::List::Iterator it;
  for( it = mEmailList.begin(); it != mEmailList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mEmailList.end() ) {
    mEmailList.erase( it );
  }
  return true;
}

Emails Emails::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "emails" ) {
    qCritical() << "Expected 'emails', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Emails();
  }

  Emails result = Emails();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "email" ) {
      bool ok;
      Email o = Email::parseElement( e, &ok );
      if ( ok ) result.addEmail( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Emails::writeElement( QXmlStreamWriter &xml )
{
  if ( !emailList().isEmpty() ) {
    xml.writeStartElement( "emails" );
    foreach( Email e, emailList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


bool Group::isValid() const
{
  return !mId.isEmpty();
}

void Group::setId( const QString &v )
{
  mId = v;
}

QString Group::id() const
{
  return mId;
}

Group Group::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "group" ) {
    qCritical() << "Expected 'group', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Group();
  }

  Group result = Group();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Group::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "group" );
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  xml.writeEndElement();
}


void Groups::addGroup( const Group &v )
{
  mGroupList.append( v );
}

void Groups::setGroupList( const Group::List &v )
{
  mGroupList = v;
}

Group::List Groups::groupList() const
{
  return mGroupList;
}

Group Groups::findGroup( const QString &id, Flags flags )
{
  foreach( Group v, mGroupList ) {
    if ( v.id() == id ) return v;
  }
  Group v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Groups::insert( const Group &v )
{
  int i = 0;
  for( ; i < mGroupList.size(); ++i ) {
    if ( mGroupList[i].id() == v.id() ) {
      mGroupList[i] = v;
      return true;
    }
  }
  if ( i == mGroupList.size() ) {
    addGroup( v );
  }
  return true;
}

bool Groups::remove( const Group &v )
{
  Group::List::Iterator it;
  for( it = mGroupList.begin(); it != mGroupList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mGroupList.end() ) {
    mGroupList.erase( it );
  }
  return true;
}

Groups Groups::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "groups" ) {
    qCritical() << "Expected 'groups', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Groups();
  }

  Groups result = Groups();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "group" ) {
      bool ok;
      Group o = Group::parseElement( e, &ok );
      if ( ok ) result.addGroup( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Groups::writeElement( QXmlStreamWriter &xml )
{
  if ( !groupList().isEmpty() ) {
    xml.writeStartElement( "groups" );
    foreach( Group e, groupList() ) {
      e.writeElement( xml );
    }
    xml.writeEndElement();
  }
}


Name::Name()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

void Name::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Name::createdAt() const
{
  return mCreatedAt;
}

void Name::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Name::updatedAt() const
{
  return mUpdatedAt;
}

void Name::setValue( const QString &v )
{
  mValue = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QString Name::value() const
{
  return mValue;
}

Name Name::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "name" ) {
    qCritical() << "Expected 'name', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Name();
  }

  Name result = Name();

  result.setValue( element.text() );
  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Name::writeElement( QXmlStreamWriter &xml )
{
  if ( !value().isEmpty() ) {
    xml.writeStartElement( "name" );
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    xml.writeCharacters( value() );
    xml.writeEndElement();
  }
}


Birthday::Birthday()
{
  QDateTime now = QDateTime::currentDateTime();
  setCreatedAt( now );
  setUpdatedAt( now );
}

void Birthday::setCreatedAt( const QDateTime &v )
{
  mCreatedAt = v;
}

QDateTime Birthday::createdAt() const
{
  return mCreatedAt;
}

void Birthday::setUpdatedAt( const QDateTime &v )
{
  mUpdatedAt = v;
}

QDateTime Birthday::updatedAt() const
{
  return mUpdatedAt;
}

void Birthday::setValue( const QDate &v )
{
  mValue = v;
  setUpdatedAt( QDateTime::currentDateTime() );
}

QDate Birthday::value() const
{
  return mValue;
}

Birthday Birthday::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "birthday" ) {
    qCritical() << "Expected 'birthday', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Birthday();
  }

  Birthday result = Birthday();

  result.setValue( QDate::fromString( element.text(), "yyyyMMdd" ) );
  result.setCreatedAt( QDateTime::fromString( element.attribute( "created_at" ), "yyyyMMddThhmmssZ" ) );
  result.setUpdatedAt( QDateTime::fromString( element.attribute( "updated_at" ), "yyyyMMddThhmmssZ" ) );

  if ( ok ) *ok = true;
  return result;
}

void Birthday::writeElement( QXmlStreamWriter &xml )
{
  if ( value().isValid() ) {
    xml.writeStartElement( "birthday" );
    if ( !createdAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "created_at", createdAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    if ( !updatedAt().toString( "yyyyMMddThhmmssZ" ).isEmpty() ) {
      xml.writeAttribute( "updated_at", updatedAt().toString( "yyyyMMddThhmmssZ" ) );
    }
    xml.writeCharacters( value().toString( "yyyyMMdd" ) );
    xml.writeEndElement();
  }
}


bool Identity::isValid() const
{
  return !mId.isEmpty();
}

void Identity::setType( const QString &v )
{
  mType = v;
}

QString Identity::type() const
{
  return mType;
}

void Identity::setId( const QString &v )
{
  mId = v;
}

QString Identity::id() const
{
  return mId;
}

void Identity::setGroups( const Groups &v )
{
  mGroups = v;
}

Groups Identity::groups() const
{
  return mGroups;
}

void Identity::setName( const Name &v )
{
  mName = v;
}

Name Identity::name() const
{
  return mName;
}

void Identity::setBirthday( const Birthday &v )
{
  mBirthday = v;
}

Birthday Identity::birthday() const
{
  return mBirthday;
}

void Identity::setEmails( const Emails &v )
{
  mEmails = v;
}

Emails Identity::emails() const
{
  return mEmails;
}

void Identity::setDetails(const Details &v)
{
    mDetails = v;
}

Details Identity::details() const
{
    return mDetails;
}

void Identity::setPictures( const Pictures &v )
{
  mPictures = v;
}

Pictures Identity::pictures() const
{
  return mPictures;
}

void Identity::setPhones( const Phones &v )
{
  mPhones = v;
}

Phones Identity::phones() const
{
  return mPhones;
}

void Identity::setAddresses( const Addresses &v )
{
  mAddresses = v;
}

Addresses Identity::addresses() const
{
  return mAddresses;
}

void Identity::setRelations( const Relations &v )
{
  mRelations = v;
}

Relations Identity::relations() const
{
  return mRelations;
}

void Identity::setLinks( const Links &v )
{
  mLinks = v;
}

Links Identity::links() const
{
  return mLinks;
}

void Identity::setExtendedAttributes( const ExtendedAttributes &v )
{
  mExtendedAttributes = v;
}

ExtendedAttributes Identity::extendedAttributes() const
{
  return mExtendedAttributes;
}

void Identity::setComments( const Comments &v )
{
  mComments = v;
}

Comments Identity::comments() const
{
  return mComments;
}

Identity Identity::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "identity" ) {
    qCritical() << "Expected 'identity', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Identity();
  }

  Identity result = Identity();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "groups" ) {
      bool ok;
      Groups o = Groups::parseElement( e, &ok );
      if ( ok ) result.setGroups( o );
    }
    else if ( e.tagName() == "name" ) {
      bool ok;
      Name o = Name::parseElement( e, &ok );
      if ( ok ) result.setName( o );
    }
    else if ( e.tagName() == "birthday" ) {
      bool ok;
      Birthday o = Birthday::parseElement( e, &ok );
      if ( ok ) result.setBirthday( o );
    }
    else if ( e.tagName() == "emails" ) {
      bool ok;
      Emails o = Emails::parseElement( e, &ok );
      if ( ok ) result.setEmails( o );
    }
    else if ( e.tagName() == "details" ) {
      bool ok;
      Details o = Details::parseElement( e, &ok );
      if ( ok ) result.setDetails( o );
    }
    else if ( e.tagName() == "pictures" ) {
      bool ok;
      Pictures o = Pictures::parseElement( e, &ok );
      if ( ok ) result.setPictures( o );
    }
    else if ( e.tagName() == "phones" ) {
      bool ok;
      Phones o = Phones::parseElement( e, &ok );
      if ( ok ) result.setPhones( o );
    }
    else if ( e.tagName() == "addresses" ) {
      bool ok;
      Addresses o = Addresses::parseElement( e, &ok );
      if ( ok ) result.setAddresses( o );
    }
    else if ( e.tagName() == "relations" ) {
      bool ok;
      Relations o = Relations::parseElement( e, &ok );
      if ( ok ) result.setRelations( o );
    }
    else if ( e.tagName() == "links" ) {
      bool ok;
      Links o = Links::parseElement( e, &ok );
      if ( ok ) result.setLinks( o );
    }
    else if ( e.tagName() == "extended_attributes" ) {
      bool ok;
      ExtendedAttributes o = ExtendedAttributes::parseElement( e, &ok );
      if ( ok ) result.setExtendedAttributes( o );
    }
    else if ( e.tagName() == "comments" ) {
      bool ok;
      Comments o = Comments::parseElement( e, &ok );
      if ( ok ) result.setComments( o );
    }
  }

  result.setType( element.attribute( "type" ) );

  if ( ok ) *ok = true;
  return result;
}

void Identity::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "identity" );
    if ( !type().isEmpty() ) {
      xml.writeAttribute( "type", type() );
    }
  if ( !id().isEmpty() ) {
    xml.writeTextElement(  "id", id() );
  }
  groups().writeElement( xml );
  name().writeElement( xml );
  birthday().writeElement( xml );
  emails().writeElement( xml );
  details().writeElement( xml );
  pictures().writeElement( xml );
  phones().writeElement( xml );
  addresses().writeElement( xml );
  relations().writeElement( xml );
  links().writeElement( xml );
  extendedAttributes().writeElement( xml );
  comments().writeElement( xml );
  xml.writeEndElement();
}


void Root::setGroup( const Group &v )
{
  mGroup = v;
}

Group Root::group() const
{
  return mGroup;
}

Root Root::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "root" ) {
    qCritical() << "Expected 'root', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Root();
  }

  Root result = Root();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "group" ) {
      bool ok;
      Group o = Group::parseElement( e, &ok );
      if ( ok ) result.setGroup( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

void Root::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "root" );
  group().writeElement( xml );
  xml.writeEndElement();
}


void Polka::setSchemaVersion( int v )
{
  mSchemaVersion = v;
}

int Polka::schemaVersion() const
{
  return mSchemaVersion;
}

void Polka::setRoot( const Root &v )
{
  mRoot = v;
}

Root Polka::root() const
{
  return mRoot;
}

void Polka::addIdentity( const Identity &v )
{
  mIdentityList.append( v );
}

void Polka::setIdentityList( const Identity::List &v )
{
  mIdentityList = v;
}

Identity::List Polka::identityList() const
{
  return mIdentityList;
}

Identity Polka::findIdentity( const QString &id, Flags flags )
{
  foreach( Identity v, mIdentityList ) {
    if ( v.id() == id ) return v;
  }
  Identity v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Polka::insert( const Identity &v )
{
  int i = 0;
  for( ; i < mIdentityList.size(); ++i ) {
    if ( mIdentityList[i].id() == v.id() ) {
      mIdentityList[i] = v;
      return true;
    }
  }
  if ( i == mIdentityList.size() ) {
    addIdentity( v );
  }
  return true;
}

bool Polka::remove( const Identity &v )
{
  Identity::List::Iterator it;
  for( it = mIdentityList.begin(); it != mIdentityList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mIdentityList.end() ) {
    mIdentityList.erase( it );
  }
  return true;
}

void Polka::addGroupView( const GroupView &v )
{
  mGroupViewList.append( v );
}

void Polka::setGroupViewList( const GroupView::List &v )
{
  mGroupViewList = v;
}

GroupView::List Polka::groupViewList() const
{
  return mGroupViewList;
}

GroupView Polka::findGroupView( const QString &id, Flags flags )
{
  foreach( GroupView v, mGroupViewList ) {
    if ( v.id() == id ) return v;
  }
  GroupView v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Polka::insert( const GroupView &v )
{
  int i = 0;
  for( ; i < mGroupViewList.size(); ++i ) {
    if ( mGroupViewList[i].id() == v.id() ) {
      mGroupViewList[i] = v;
      return true;
    }
  }
  if ( i == mGroupViewList.size() ) {
    addGroupView( v );
  }
  return true;
}

bool Polka::remove( const GroupView &v )
{
  GroupView::List::Iterator it;
  for( it = mGroupViewList.begin(); it != mGroupViewList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mGroupViewList.end() ) {
    mGroupViewList.erase( it );
  }
  return true;
}

Polka Polka::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "polka" ) {
    qCritical() << "Expected 'polka', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Polka();
  }

  Polka result = Polka();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "root" ) {
      bool ok;
      Root o = Root::parseElement( e, &ok );
      if ( ok ) result.setRoot( o );
    }
    else if ( e.tagName() == "identity" ) {
      bool ok;
      Identity o = Identity::parseElement( e, &ok );
      if ( ok ) result.addIdentity( o );
    }
    else if ( e.tagName() == "group_view" ) {
      bool ok;
      GroupView o = GroupView::parseElement( e, &ok );
      if ( ok ) result.addGroupView( o );
    }
  }

  result.setSchemaVersion( element.attribute( "schemaVersion" ).toInt() );

  if ( ok ) *ok = true;
  return result;
}

void Polka::writeElement( QXmlStreamWriter &xml )
{
  xml.writeStartElement( "polka" );
    if ( !QString::number( schemaVersion() ).isEmpty() ) {
      xml.writeAttribute( "schemaVersion", QString::number( schemaVersion() ) );
    }
  root().writeElement( xml );
  foreach( Identity e, identityList() ) {
    e.writeElement( xml );
  }
  foreach( GroupView e, groupViewList() ) {
    e.writeElement( xml );
  }
  xml.writeEndElement();
}

Polka Polka::parseFile( const QString &filename, bool *ok )
{
  QFile file( filename );
  if ( !file.open( QIODevice::ReadOnly ) ) {
    qCritical() << "Unable to open file '" << filename << "'";
    if ( ok ) *ok = false;
    return Polka();
  }

  QString errorMsg;
  int errorLine, errorCol;
  QDomDocument doc;
  if ( !doc.setContent( &file, false, &errorMsg, &errorLine, &errorCol ) ) {
    qCritical() << errorMsg << " at " << errorLine << "," << errorCol;
    if ( ok ) *ok = false;
    return Polka();
  }

  bool documentOk;
  Polka c = parseElement( doc.documentElement(), &documentOk );
  if ( ok ) {
    *ok = documentOk;
  }
  return c;
}

Polka Polka::parseString( const QString &xml, bool *ok )
{
  QString errorMsg;
  int errorLine, errorCol;
  QDomDocument doc;
  if ( !doc.setContent( xml, false, &errorMsg, &errorLine, &errorCol ) ) {
    qCritical() << errorMsg << " at " << errorLine << "," << errorCol;
    if ( ok ) *ok = false;
    return Polka();
  }

  bool documentOk;
  Polka c = parseElement( doc.documentElement(), &documentOk );
  if ( ok ) {
    *ok = documentOk;
  }
  return c;
}

bool Polka::writeFile( const QString &filename )
{
  QFile file( filename );
  if ( !file.open( QIODevice::WriteOnly ) ) {
    qCritical() << "Unable to open file '" << filename << "'";
    return false;
  }

  QXmlStreamWriter xml( &file );
  xml.setAutoFormatting( true );
  xml.setAutoFormattingIndent( 2 );
  xml.writeStartDocument( "1.0" );
  writeElement( xml );
  xml.writeEndDocument();
  file.close();

  return true;
}


}

